/*
  gsl_rng.c
  Ruby/Numo::GSL - GSL wrapper for Ruby/Numo::NArray
    (C) Copyright 1999-2007,2013-2017 by Masahiro TANAKA

  This program is free software.
  You can distribute/modify this program
  under the same terms as GPL3.
  NO WARRANTY.
*/

#include <ruby.h>
#include "numo/narray.h"
#include "numo/template.h"
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>

<% RNG_TYPES = "
GSL_VAR const gsl_rng_type *gsl_rng_borosh13;
GSL_VAR const gsl_rng_type *gsl_rng_coveyou;
GSL_VAR const gsl_rng_type *gsl_rng_cmrg;
GSL_VAR const gsl_rng_type *gsl_rng_fishman18;
GSL_VAR const gsl_rng_type *gsl_rng_fishman20;
GSL_VAR const gsl_rng_type *gsl_rng_fishman2x;
GSL_VAR const gsl_rng_type *gsl_rng_gfsr4;
GSL_VAR const gsl_rng_type *gsl_rng_knuthran;
GSL_VAR const gsl_rng_type *gsl_rng_knuthran2;
GSL_VAR const gsl_rng_type *gsl_rng_knuthran2002;
GSL_VAR const gsl_rng_type *gsl_rng_lecuyer21;
GSL_VAR const gsl_rng_type *gsl_rng_minstd;
GSL_VAR const gsl_rng_type *gsl_rng_mrg;
GSL_VAR const gsl_rng_type *gsl_rng_mt19937;
GSL_VAR const gsl_rng_type *gsl_rng_mt19937_1999;
GSL_VAR const gsl_rng_type *gsl_rng_mt19937_1998;
GSL_VAR const gsl_rng_type *gsl_rng_r250;
GSL_VAR const gsl_rng_type *gsl_rng_ran0;
GSL_VAR const gsl_rng_type *gsl_rng_ran1;
GSL_VAR const gsl_rng_type *gsl_rng_ran2;
GSL_VAR const gsl_rng_type *gsl_rng_ran3;
GSL_VAR const gsl_rng_type *gsl_rng_rand;
GSL_VAR const gsl_rng_type *gsl_rng_rand48;
GSL_VAR const gsl_rng_type *gsl_rng_random128_bsd;
GSL_VAR const gsl_rng_type *gsl_rng_random128_glibc2;
GSL_VAR const gsl_rng_type *gsl_rng_random128_libc5;
GSL_VAR const gsl_rng_type *gsl_rng_random256_bsd;
GSL_VAR const gsl_rng_type *gsl_rng_random256_glibc2;
GSL_VAR const gsl_rng_type *gsl_rng_random256_libc5;
GSL_VAR const gsl_rng_type *gsl_rng_random32_bsd;
GSL_VAR const gsl_rng_type *gsl_rng_random32_glibc2;
GSL_VAR const gsl_rng_type *gsl_rng_random32_libc5;
GSL_VAR const gsl_rng_type *gsl_rng_random64_bsd;
GSL_VAR const gsl_rng_type *gsl_rng_random64_glibc2;
GSL_VAR const gsl_rng_type *gsl_rng_random64_libc5;
GSL_VAR const gsl_rng_type *gsl_rng_random8_bsd;
GSL_VAR const gsl_rng_type *gsl_rng_random8_glibc2;
GSL_VAR const gsl_rng_type *gsl_rng_random8_libc5;
GSL_VAR const gsl_rng_type *gsl_rng_random_bsd;
GSL_VAR const gsl_rng_type *gsl_rng_random_glibc2;
GSL_VAR const gsl_rng_type *gsl_rng_random_libc5;
GSL_VAR const gsl_rng_type *gsl_rng_randu;
GSL_VAR const gsl_rng_type *gsl_rng_ranf;
GSL_VAR const gsl_rng_type *gsl_rng_ranlux;
GSL_VAR const gsl_rng_type *gsl_rng_ranlux389;
GSL_VAR const gsl_rng_type *gsl_rng_ranlxd1;
GSL_VAR const gsl_rng_type *gsl_rng_ranlxd2;
GSL_VAR const gsl_rng_type *gsl_rng_ranlxs0;
GSL_VAR const gsl_rng_type *gsl_rng_ranlxs1;
GSL_VAR const gsl_rng_type *gsl_rng_ranlxs2;
GSL_VAR const gsl_rng_type *gsl_rng_ranmar;
GSL_VAR const gsl_rng_type *gsl_rng_slatec;
GSL_VAR const gsl_rng_type *gsl_rng_taus;
GSL_VAR const gsl_rng_type *gsl_rng_taus2;
GSL_VAR const gsl_rng_type *gsl_rng_taus113;
GSL_VAR const gsl_rng_type *gsl_rng_transputer;
GSL_VAR const gsl_rng_type *gsl_rng_tt800;
GSL_VAR const gsl_rng_type *gsl_rng_uni;
GSL_VAR const gsl_rng_type *gsl_rng_uni32;
GSL_VAR const gsl_rng_type *gsl_rng_vax;
GSL_VAR const gsl_rng_type *gsl_rng_waterman14;
GSL_VAR const gsl_rng_type *gsl_rng_zuf;
".split(/$/).map{|x| /gsl_rng_(\w+);/=~x; $1}.compact
def camelize(s)
  s.capitalize.gsub(/_([a-z])/){$1.upcase}
end
%>

/* :nodoc: */
static VALUE
rng_s_alloc(VALUE klass)
{
    gsl_rng *rng;

    rng = gsl_rng_alloc(gsl_rng_default);
    return Data_Wrap_Struct(klass, 0, gsl_rng_free, rng);
}

<% RNG_TYPES.each do |x| %>
/* :nodoc: */
static VALUE
rng_<%=x%>_s_alloc(VALUE klass)
{
    gsl_rng *rng;

    rng = gsl_rng_alloc(gsl_rng_<%=x%>);
    return Data_Wrap_Struct(klass, 0, gsl_rng_free, rng);
}
<% end %>

/*
  Creates a new PRNG using +seed+ to set the initial state.
  If +seed+ is omitted, the generator is initialized with
  Numo::GSL::Rng.default_seed.
  @overload initialize([seed])
*/
static VALUE
rng_init(int argc, VALUE *argv, VALUE self)
{
    gsl_rng *rng;

    if (argc == 1) {
        Data_Get_Struct(self, gsl_rng, rng);
        gsl_rng_set(rng, NUM2ULONG(argv[0]));
    } else if (argc > 1) {
        rb_raise(rb_eArgError,"wrong number of arguments (given %d, expected 1)", argc);
    }
    return self;
}


/*
  This function initializes (or ‘seeds’) the random number
  generator. If the generator is seeded with the same value of s on
  two different runs, the same stream of random numbers will be
  generated by successive calls to the routines below. If different
  values of s >= 1 are supplied, then the generated streams of random
  numbers should be completely different. If the seed s is zero then
  the standard seed from the original implementation is used
  instead. For example, the original Fortran source code for the
  ranlux generator used a seed of 314159265, and so choosing s equal
  to zero reproduces this when using gsl_rng_ranlux.

  When using multiple seeds with the same generator, choose seed
  values greater than zero to avoid collisions with the default
  setting.

  Note that the most generators only accept 32-bit seeds, with higher
  values being reduced modulo 2^32. For generators with smaller ranges
  the maximum seed value will typically be lower.
*/
static VALUE
rng_set(VALUE self, VALUE seed)
{
    gsl_rng *r;

    Data_Get_Struct(self, gsl_rng, r);
    gsl_rng_set(r, NUM2ULONG(seed));
    return Qnil;
}

/*
  This function returns a random integer from the generator.
  The minimum and maximum values depend on the algorithm used, but all
  integers in the range [min,max] are equally likely.
  The values of min and max can be determined using the auxiliary
  functions gsl_rng_max (r) and gsl_rng_min (r).

  @overload get
  @return [Integer]  returns random number
*/
static VALUE
rng_get(VALUE self)
{
    gsl_rng *r;

    Data_Get_Struct(self, gsl_rng, r);
    return ULONG2NUM(gsl_rng_get(r));
}


static VALUE
create_new_narray(VALUE datatype, VALUE vshape)
{
    size_t size, *shape;
    int j, ndim;

    switch(TYPE(vshape)) {
    case T_FIXNUM:
    case T_BIGNUM:
        size = NUM2SIZET(vshape);
        ndim = 1;
        shape = &size;
        break;
    case T_ARRAY:
        ndim = RARRAY_LEN(vshape);
        shape = ALLOCA_N(size_t,ndim);
        size = 1;
        for (j=0; j<ndim; j++) {
            shape[j] = NUM2SIZET(RARRAY_AREF(vshape,j));
        }
        break;
    default:
        rb_raise(rb_eArgError,"invalid argument for shape");
    }
    return rb_narray_new(datatype,ndim,shape);
}

/*
  This function returns a double precision floating point number
  uniformly distributed in the range [0,1). The range includes 0.0 but
  excludes 1.0. The value is typically obtained by dividing the result
  of gsl_rng_get(r) by gsl_rng_max(r) + 1.0 in double precision. Some
  generators compute this ratio internally so that they can provide
  floating point numbers with more than 32 bits of randomness (the
  maximum number of bits that can be portably represented in a single
  unsigned long int).

  @overload uniform([shape])
  @param  [Array or Integer]  shape (optional) shape for result NArray
  @return [Float or DFloat]  returns random number
*/
static VALUE
rng_uniform(int argc, VALUE *argv, VALUE self)
{
    VALUE vshape, vna;
    size_t i, size;
    double *ptr;
    gsl_rng *r;
    Data_Get_Struct(self, gsl_rng, r);

    if (rb_scan_args(argc, argv, "01", &vshape) == 0) {
        return rb_float_new(gsl_rng_uniform(r));
    } else {
        vna = create_new_narray(numo_cDFloat,vshape);
        ptr = (double*)na_get_pointer_for_write(vna);
        size = RNARRAY_SIZE(vna);
        for (i=0; i<size; i++) {
            ptr[i] = gsl_rng_uniform(r);
        }
        return vna;
    }
}

/*
  This function returns a positive double precision floating point
  number uniformly distributed in the range (0,1), excluding both 0.0
  and 1.0. The number is obtained by sampling the generator with the
  algorithm of gsl_rng_uniform until a non-zero value is obtained. You
  can use this function if you need to avoid a singularity at 0.0.

  @overload uniform_pos([shape])
  @param  [Array or Integer]  shape (optional) shape for result NArray
  @return [Float or DFloat]  returns random number
 */
static VALUE
rng_uniform_pos(int argc, VALUE *argv, VALUE self)
{
    VALUE vshape, vna;
    size_t i, size;
    double *ptr;
    gsl_rng *r;
    Data_Get_Struct(self, gsl_rng, r);

    if (rb_scan_args(argc, argv, "01", &vshape) == 0) {
        return rb_float_new(gsl_rng_uniform_pos(r));
    } else {
        vna = create_new_narray(numo_cDFloat,vshape);
        ptr = (double*)na_get_pointer_for_write(vna);
        size = RNARRAY_SIZE(vna);
        for (i=0; i<size; i++) {
            ptr[i] = gsl_rng_uniform_pos(r);
        }
        return vna;
    }
}

/*
  This function returns a random integer from 0 to n-1 inclusive by
  scaling down and/or discarding samples from the generator r. All
  integers in the range [0,n-1] are produced with equal
  probability. For generators with a non-zero minimum value an offset
  is applied so that zero is returned with the correct probability.

  Note that this function is designed for sampling from ranges smaller
  than the range of the underlying generator. The parameter n must be
  less than or equal to the range of the generator r. If n is larger
  than the range of the generator then the function calls the error
  handler with an error code of GSL_EINVAL and returns zero.

  In particular, this function is not intended for generating the full
  range of unsigned integer values [0,2^32-1]. Instead choose a
  generator with the maximal integer range and zero minimum value,
  such as gsl_rng_ranlxd1, gsl_rng_mt19937 or gsl_rng_taus, and sample
  it directly using gsl_rng_get. The range of each generator can be
  found using the auxiliary functions described in the next section.

  @overload uniform_int(n,[shape])
  @param  [Integer]  n
  @param  [Array or Integer]  shape (optional) shape for result NArray
  @return [Float or DFloat]  returns random number
 */

static VALUE
rng_uniform_int(int argc, VALUE *argv, VALUE self)
{
    VALUE vshape, vna, vn;
    size_t i, size;
    int nargs;
    unsigned long n;
    u_int32_t *p32;
    u_int64_t *p64;
    gsl_rng *r;
    Data_Get_Struct(self, gsl_rng, r);

    nargs = rb_scan_args(argc, argv, "11", &vn, &vshape);
    n = NUM2ULONG(vn);
    if (nargs == 1) {
        return ULONG2NUM(gsl_rng_uniform_int(r, n));
    } else {
        if (n > 4294967295ul) {
            vna = create_new_narray(numo_cUInt64,vshape);
            p64 = (u_int64_t*)na_get_pointer_for_write(vna);
            size = RNARRAY_SIZE(vna);
            for (i=0; i<size; i++) {
                p64[i] = (u_int64_t)gsl_rng_uniform_int(r, n);
            }
        } else {
            vna = create_new_narray(numo_cUInt32,vshape);
            p32 = (u_int32_t*)na_get_pointer_for_write(vna);
            size = RNARRAY_SIZE(vna);
            for (i=0; i<size; i++) {
                p32[i] = (u_int32_t)gsl_rng_uniform_int(r, n);
            }
        }
        return vna;
    }
}

/*
  This function returns a pointer to the name of the generator.
*/
static VALUE
rng_name(VALUE self)
{
    gsl_rng *r;

    Data_Get_Struct(self, gsl_rng, r);
    return rb_str_new2(gsl_rng_name(r));
}

/*
  This function returns the largest value that gsl_rng_get can return.
*/
static VALUE
rng_max(VALUE self)
{
    gsl_rng *r;

    Data_Get_Struct(self, gsl_rng, r);
    return ULONG2NUM(gsl_rng_max(r));
}

/*
  This function returns the smallest value that gsl_rng_get can
  return. Usually this value is zero. There are some generators with
  algorithms that cannot return zero, and for these generators the
  minimum value is 1.
*/
static VALUE
rng_min(VALUE self)
{
    gsl_rng *r;

    Data_Get_Struct(self, gsl_rng, r);
    return ULONG2NUM(gsl_rng_min(r));
}

/*
  This function return the size of the state of generator.
*/
static VALUE
rng_size(VALUE self)
{
    gsl_rng *r;

    Data_Get_Struct(self, gsl_rng, r);
    return ULONG2NUM(gsl_rng_size(r));
}

static VALUE
rng_clone(VALUE self)
{
    gsl_rng *r, *clone;

    Data_Get_Struct(self, gsl_rng, r);
    clone = gsl_rng_clone(r);
    return Data_Wrap_Struct(CLASS_OF(self), 0, gsl_rng_free, clone);
}


/* Default seed */
static VALUE
rng_s_default_seed(VALUE self)
{
    return ULONG2NUM(gsl_rng_default_seed);
}


<%
$defs = []
f = eval(open("../ran/gen/func_def.rb").read).
    select{|h| h[:func_name] =~ /^gsl_ran_(.*)$/}

f.each do |h|
  func_name = h[:func_name]
  name = func_name.sub(/^gsl_ran_/,"")
  args = h[:args]

  if args.shift[0] == "const gsl_rng *"
    an = []
    vn = []
    vardef = []
    varconv = []
    params = []
    unknown = false
    args.each_with_index do |tn,i|
      if /^\w+$/ !~ tn[1] # pointer?
        unknown = true
        break
      end
      an << a = "a#{i}"
      vn << v = "v#{i}"
      case tn[0]
      when "double"
        varconv << "#{a} = NUM2DBL(#{v});"
        params << [tn[1],"Float"]
      when "unsigned int"
        varconv << "#{a} = NUM2UINT(#{v});"
        params << [tn[1],"Integer"]
      else
        unknown = true
        break
      end
      vardef << "#{tn[0]} #{a}"
    end
    if unknown
      $stderr.puts "not defined: #{func_name} #{h[:args].inspect}"
      next
    end
    $defs << "rb_define_method(cRng, \"#{name}\", numo_gsl_ran_#{name}, -1);"
    n = args.size
%>
/*
  @overload <%= name %>(<%params.each{|x|%><%=x[0]%>,<%}%>[shape])
  <% params.each do |x|%>
  @param  [<%=x[1]%>]  <%=x[0]%><% end %>
  @param  [Array or Integer]  shape (optional) shape for result NArray
  @return [Float or DFloat]  returns random number

<%= h[:desc] %>
 */
static VALUE
numo_gsl_ran_<%=name%>(int argc, VALUE *argv, VALUE self)
{
    VALUE vshape, vna;
    size_t i, size;
    int nargs;
    double *ptr;
    gsl_rng *r;
    <% vn.each do |v|%>
    VALUE <%=v%>;<% end %>
    <% vardef.each do |x|%>
    <%=x%>;<% end %>

    Data_Get_Struct(self, gsl_rng, r);

    nargs = rb_scan_args(argc, argv, "<%=n%>1" <%vn.map{|v|%>, &<%=v%><%}%>, &vshape);
    <% varconv.each do |x|%><%=x%>
    <% end %>
    if (nargs == <%=n%>) {
        return rb_float_new(<%=func_name%>(r <%an.map{|a|%>, <%=a%><%}%>));
    } else {
        vna = create_new_narray(numo_cDFloat,vshape);
        ptr = (double*)na_get_pointer_for_write(vna);
        size = RNARRAY_SIZE(vna);
        for (i=0; i<size; i++) {
            ptr[i] = <%=func_name%>(r <%an.map{|a|%>, <%=a%><%}%>);
        }
        return vna;
    }
}
<% end; end %>


void
Init_rng()
{
    VALUE mNumo, mGsl, cRng;

    mNumo = rb_define_module("Numo");
    mGsl = rb_define_module_under(mNumo, "GSL");
    cRng = rb_define_class_under(mGsl, "Rng", rb_cObject);

    gsl_rng_env_setup();

    rb_define_alloc_func(cRng, rng_s_alloc);
    rb_define_method(cRng, "initialize", rng_init, -1);

    rb_define_method(cRng, "set", rng_set, 1);
    rb_define_alias( cRng, "set_seed", "set");
    rb_define_alias( cRng, "seed=", "set");
    rb_define_method(cRng, "get", rng_get, 0);
    rb_define_method(cRng, "uniform", rng_uniform, -1);
    rb_define_method(cRng, "uniform_pos", rng_uniform_pos, -1);
    rb_define_method(cRng, "uniform_int", rng_uniform_int, -1);

    rb_define_method(cRng, "name", rng_name, 0);
    rb_define_method(cRng, "max", rng_max, 0);
    rb_define_method(cRng, "min", rng_min, 0);
    rb_define_method(cRng, "size", rng_size, 0);

    rb_define_method(cRng, "clone", rng_clone, 0);
    rb_define_alias( cRng, "dup", "clone");
    rb_define_singleton_method(cRng, "default_seed", rng_s_default_seed, 0);

    <% RNG_TYPES.each do |x| c = camelize(x)%>
    { VALUE c<%=c%> = rb_define_class_under(cRng, "<%=c%>", cRng);
      rb_define_alloc_func(c<%=c%>, rng_<%=x%>_s_alloc); }<% end %>

    <% $defs.each do |x| %>
    <%=x%><% end %>
}
